<!DOCTYPE html>

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    

    <link rel="stylesheet" type="text/css" href="res/main.css">
    <link rel="stylesheet" type="text/css" href="res/common.css">
    <link rel="stylesheet" type="text/css" href="res/table-task.css">
    <link rel="stylesheet" type="text/css" href="res/table-example.css">
    <link rel="stylesheet" type="text/css" href="res/prettify.css">
    <link rel="stylesheet" type="text/css" href="res/legacy.css">

    <title> JavaRush | Уровень 27</title>

    
    <link rel="shortcut icon" href="res/javarush.ico" type="image/ico">

    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
</head>
<body>







<div class="wrapper">

<section class="lesson" style="">
        <h2> Вы достигли нового уровня </h2>
        <div style="width: 100%;height:450px;">
            <div style="width:850px;height:478px;margin-left:-150px;margin-right: 150px;   background: url(images/profile/web-bender-27.gif) no-repeat;background-size: contain;">
                <div style="width: 300px;height: 50px;display: inline-block; font-size: 30pt;text-align: left;margin-top: 200px;margin-left: 700px;">
                    Уровень 27
                </div>
            </div>
        </div>
        <br>
        <div class="line"></div>
        <div class="section_footer">
            <button class="next_lesson" style="visibility: hidden;"></button>
            <!--<div class="line"></div>-->
        </div>
    </section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar zoidberg"></div>
        <h2>1. Циклы (break и return, continue, метки)</h2>
    </div>
    <img src="res/image-ru-27-07.png" alt="" class="cartoon">  
    <p>- Привет, Амиго!</p> 
    <p>Сегодня я тебе расскажу про некоторые удобные вещи в работе с циклами.</p>
    <p>Первая такая вещь – это ключевое слово <b>break</b>. Если в теле цикла написать такую инструкцию, то при ее выполнении цикл сразу завершится. Пример:</p>
    <table class="table_example">
        <tbody><tr><th width="50%">Пример</th><th width="50%">Результат работы цикла:</th></tr>
    <tr>
    <td class="monospace_text wide-text"><b>for</b> (int i=0;i&lt;10;i++)<br>
{<br>
   &nbsp;System.out.println(i);<br>
   &nbsp;<b>if</b> (i&gt;5) <br>
      &nbsp;&nbsp;<b>break</b>;<br>
}
    </td>
    <td class="wide-text">0<br>
    1<br>
    2<br>
    3<br>
    4<br>
    5
    </td>
            </tr>
    </tbody></table>
    <p class="amigo">- А break можно использовать только в цикле?</p>
    <p>- Да. break можно использовать только в цикле. При выполнении команды <b>break</b> цикл тут же завершается.</p>
    <p class="amigo">- Ок. Понятно.</p>
    <p>- Отлично. Теперь вторая команда – это ключевое слово <b>continue</b>. Его тоже можно использовать только в цикле. При выполнении этой команды, сразу начинается новая итерация цикла.  Другими словами, просто пропускается весь код тела цикла.</p>
    <p>Пример:</p>
    <table class="table_example">
        <tbody><tr><th width="50%">Пример</th><th width="50%">Результат работы цикла:</th></tr>
    <tr>
    <td class="monospace_text wide-text"><b>for</b> (int i=0;i&lt;10;i++)<br>
{<br>
   &nbsp;<b>if</b> (i%2==0) <br>
      &nbsp;&nbsp;<b>continue</b>;<br>
   &nbsp;System.out.println(i);<br>
}
    </td>
    <td class="wide-text">1<br>
    3<br>
    5<br>
    7<br>
    9
    </td>
            </tr>
    </tbody></table>
    <p class="amigo">- Т.е. как только программа доходит до исполнения  команды <b>continue</b> внутри цикла, она перестает выполнять код в нем? </p>
    <p>- Нет. Смотри. Цикл – это когда мы выполняем один и то же код несколько раз. В примере выше – у нас цикл от 0 до 9 – т.е. тело цикла выполнится 10 раз. Так?</p>
    <p class="amigo">- Да.</p>
    <p>- Одно такое исполнение кода тела цикла называется итерацией цикла. Наш цикл состоит из 10 итераций – десяти исполнений кода в его теле.</p>
    <p class="amigo">- Да, это ясно.</p>
    <p>- Команда <b>continue</b> преждевременно завершает текущую итерацию - код внутри цикла пропускается и начинается новая итерация.</p>
    <p>Вот тебе еще пример:</p>
    <table class="table_example">
        <tbody><tr><th width="100%">Пример</th></tr>
    <tr>
    <td class="monospace_text wide-text">ArrayList list = new ArrayList();<br>
<b>for</b>  (Object o: list)<br>
{<br>
   &nbsp;<b>if</b> (o==null) <b>continue</b>;<br>
   &nbsp;System.out.println(o.toString());<br>
}
    </td>
            </tr>
        </tbody>
    </table>
    <p>В данном примере мы  выводим на экран строковое представление всех объектов, содержащихся в списке list. Но пропускаем все объекты, которые равны null.</p>
    <p class="amigo">- Да, ясно. Очень удобная штука, я смотрю.</p>
    <p>- Ага. Еще хочу рассказать тебе про метки. Они редко используются в Java, т.к. часто  нарушают красоту логики программы. Но ты можешь встретить их где-то в коде. Так что лучше пусть ты от меня услышишь о них, чем где-то во дворе.</p>
    <p>Давным-давно в коде разрешалось прыгать с любой строчки на любую. Для этого использовались метки и оператор <b>goto</b>. Вот как это выглядело:</p>
    <table class="table_example">
        <tbody><tr><th width="100%">Ужасный код с метками</th></tr>
    <tr>
    <td class="monospace_text wide-text">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Мир");<br>
<b>label:</b> System.out.println("Труд");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Май");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>goto</b> label;
    </td>
            </tr>
        </tbody>
    </table>
    <p>В данном примере, после выполнении команды <b>goto label</b>, программа прыгала на строку, обозначенную меткой <b>label</b>.</p>
    <p>Потом все дружно прозрели  и решили не использовать оператор <b>goto</b>. В Java его до сих пор нет, но ключевое слово <b>goto</b> зарезервировано. Мало ли…</p>
    <p class="amigo">- Т.е. ни goto, ни меток в Java нет?</p>
    <p>- Оператора goto нет, а метки есть!</p>
    <p class="amigo">- Это как же это?</p>
    <p>- Метки можно использовать в Java вместе с командами <b>continue</b> и <b>break</b>. Они используются, когда у тебя много вложенных циклов. </p>
    <p>Например, у тебя 5 вложенных циклов и ты хочешь, при выполнении некоторого условия, выйти из трех из них, но не из всех. Метки позволяют сделать это красиво:</p>
    <table class="table_example">
        <tbody><tr><th width="100%">Пример</th></tr>
    <tr>
    <td class="monospace_text wide-text"><span class="blue_text">label1:</span> <b>for</b> (int i=0;i&lt;10;i++)<br>
    &nbsp;&nbsp;<span class="red_text">label2:</span> <b>for</b> (int j=0;j&lt;10;j++)<br>
         &nbsp;&nbsp;&nbsp;<span class="green_text">label3:</span> <b>for</b> (int k=0;k&lt;10;k++)<br>
             &nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> (i==j &amp;&amp; j==k) <br>
                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b> <span class="red_text">label2</span>;
    </td>
            </tr>
    </tbody></table>
    <p>В данном примере, при выполнении команды break, мы выйдем не из цикла с переменной k, а из цикла помеченного меткой label2 – т.е. выйдем сразу из двух циклов k и j.</p>
    <p class="amigo">- И как часто это используется?</p>
    <p>- Если честно, то не часто, но мало ли. Может, встретишь где-нибудь. Это основы синтаксиса – это все надо знать!</p>
    <p class="amigo">- Ок. Спасибо, Билаабо.</p>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar zoidberg"></div>
        <h2>2. Задачи на break &amp; continue;</h2>
    </div>
    <p>- Привет, Амиго!</p>
    <table class="table_task">
        <tbody><tr>
            <th>Задачи</th>
        </tr>
        <tr>
            <td><button class="task_button" taskkey="level27,lesson02,task01" disabled=""></button><b>1. Рефакторинг</b><br><br>
                Перепишите код без использования меток, сохранив при этом логику.<br>
		Не оставляйте закомментированный код.
            </td>
        </tr>
        <tr>
            <td><button class="task_button" taskkey="level27,lesson02,task02" disabled=""></button><b>2. Нужный оператор</b><br><br>
                Вставьте в код единственную строчку - оператор (не <span class="taskcode">break</span>), чтобы выводился треугольник из букв S
            </td>
        </tr>
    </tbody></table>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar elly"></div>
        <h2>3. DeadLock, и его причины</h2>
    </div>
    <img src="res/image-ru-27-06.jpg" alt="" class="cartoon">
    <p>- Привет, Амиго!</p>
    <p>Сегодня я тебе расскажу, что такое дедлок (Dead Lock) - смертельный захват.</p>
    <p class="amigo">- Так ты же уже что-то такое рассказывала.</p>
    <p>- Ага, было дело. Но сегодня мы рассмотрим эту тему детальнее.</p>
    <p>В самом простом случае в дедлоке участвуют две нити и два объекта-мютекса. Взаимная блокировка возникает, когда:</p>
    <p><b>А)</b> Каждой нити в процессе работы нужно захватить  оба мютекса.</p>
    <p><b>Б)</b> Первая нить захватила первый мютекс и ждет освобождения второго.</p>
    <p><b>В)</b> Вторая нить захватила второй мютекс и ждет освобождения первого.</p>
    <p>Примеры:</p>
    <table class="table_example">
    <tbody><tr><th width="100%">Пример</th></tr>
    <tr>
    <td class="monospace_text wide-text"><b>public class</b> Student<br>
{<br>
  &nbsp;<b>private</b> ArrayList&lt;Student&gt;  <span class="red_text">friends</span> = new ArrayList&lt;Student&gt;();<br><br>

  &nbsp;<b>public synchronized</b> ArrayList&lt;Student&gt;  getFriends()<br>
  &nbsp;{<br>
       &nbsp;&nbsp;<b>synchronized</b>(<span class="red_text">friends</span>)<br>
       &nbsp;&nbsp;{<br>
           &nbsp;&nbsp;&nbsp;return new ArrayList(<span class="red_text">friends</span>);<br>
       &nbsp;&nbsp;}<br>
  &nbsp;}<br><br>
 
   &nbsp;<b>public synchronized</b> int getFriendsCount()<br>
  &nbsp;{<br>
       &nbsp;&nbsp;return <span class="red_text">friends</span>.size();<br>
  &nbsp;}<br><br>

   &nbsp;<b>public</b> int addFriend(Student student)<br>
  &nbsp;{<br>
     &nbsp;&nbsp;<b>synchronized</b>(<span class="red_text">friends</span>)<br>
    &nbsp;&nbsp;{<br>
       &nbsp;&nbsp;&nbsp;<span class="red_text">friends</span>.add(student)<br>
       &nbsp;&nbsp;&nbsp;return getFriendsCount ();<br>
     &nbsp;&nbsp;}<br>
  &nbsp;}<br>
}
    </td>
    </tr>
    </tbody></table>
    <p>Допустим, первая нить вызвала метод <b>getFriends</b>, тогда она сначала захватит мютекс объекта <b>this</b>, а затем мютекс объекта <b>friends</b>.</p>
    <p>Вторая нить при этом вызвала метод <b>addFriend</b>, она сначала захватывает мютекс объекта <b>friends</b>, а затем мютекс объекта <b>this</b> (при вызове getFriendsCount).</p>
    <p>Сначала все будет хорошо, но как гласит Закон Мерфи - если неприятность может случиться, она случается. Обязательно возникнет ситуация, когда первая нить успеет захватить только один мютекс, а вторая нить в это время захватит второй. Они так и будут висеть вечно в ожидании, что кто-то из них первым освободит мютекс.</p>
    <p>Еще один простой пример, нашел в книге – решил привести:</p>
    <table class="table_example">
    <tbody><tr><th width="100%">Пример</th></tr>
    <tr>
    <td class="monospace_text wide-text"><b>class</b> KnightUtil<br>
{<br>
    &nbsp;<b>public static</b> void kill(Knight knight1, Knight knight2)<br>
    &nbsp;{<br>
        &nbsp;&nbsp;<b>synchronized</b>(knight1)<br>
        &nbsp;&nbsp;{<br>
            &nbsp;&nbsp;&nbsp;<b>synchronized</b>(knight2)<br>
            &nbsp;&nbsp;&nbsp;{<br>
                &nbsp;&nbsp;&nbsp;&nbsp;knight2.live = 0;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;knight1.experiance +=100;<br>
            &nbsp;&nbsp;&nbsp;} <br>  
        &nbsp;&nbsp;}<br>
    &nbsp;}<br>
}
    </td>
    </tr>
    </tbody></table>
    <p>Есть игра, где два рыцаря сражаются друг с другом. Один рыцарь убивает другого. Это поведение отражено в методе <b>kill</b>. Туда передаются два объекта-рыцаря.</p>
    <p>Сначала мы защищаем оба объекта, чтобы никто больше не мог их изменить.</p>
    <p>Второй рыцарь умирает  (live=0)</p>
    <p>Первый рыцарь получает +100 опыта.</p>
    <p>Все вроде бы отлично, но иногда может возникнуть ситуация, когда второй рыцарь в это время атакует первого. Для него тоже вызывается этот метод, но рыцари передаются в другом порядке.</p>
    <p class="amigo">- Т.е. нам даже не нужно несколько методов для получения дедлока?</p>
    <p>- Ага. Иногда бывает достаточно одного простого метода, в котором уже могут происходить процессы, приводящие к зависанию  нитей и всей программы.</p>
    <p class="amigo">- Да, оказывается, это явление встречается чаще, чем я думал. Спасибо, Элли.</p>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar diego"></div>
        <h2>4. Задачи по написанию своих дедлоков</h2>
    </div>
    <p>- Привет, Амиго!</p>
    <table class="table_task">
        <tbody><tr>
            <th>Задачи</th>
        </tr>
        <tr>
            <td><button class="task_button" taskkey="level27,lesson04,task01" disabled=""></button><b>1. Создаем дедлок</b><br><br>
                Расставьте модификаторы так, чтобы при работе с этим кодом появился дедлок<br>
		Метод <span class="taskcode">main</span> порождает <span class="taskcode">deadLock</span>, поэтому не участвует в тестировании
        </td></tr>
        <tr>
            <td><button class="task_button" taskkey="level27,lesson04,task02" disabled=""></button><b>2. Второй вариант дедлока</b><br><br>
                В методе <span class="taskcode">secondMethod</span> в синхронизированных блоках расставьте локи так,<br>
		чтобы при использовании класса <span class="taskcode">Solution</span> нитями образовывался дедлок
            </td>
        </tr>
        <tr>
            <td><button class="idea-task-button"></button><b>3. Модификаторы и дедлоки</b><br><br>
                Расставьте модификаторы так, чтобы при работе с этим кодом появился дедлок
            </td>
        </tr>
	  
    </tbody></table>

    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar elly"></div>
        <h2>5. Стратегии избегания DeadLock</h2>
    </div>
    <img src="res/image-ru-27-05.png" alt="" class="cartoon">
    <p>- Привет, Амиго!</p>
    <p>Хочу рассказать тебе про пару стратегий избегания дедлоков.</p>
    <p>Самая лучшая стратегия – это продуманная архитектура и набор правил, когда можно использовать блокировки (захват мютексов) и в каком порядке. Классический способ борьбы с проблемой — разработка иерархии блокировок, установление правила, что некоторые блокировки никогда не могут захватываться в состоянии, в котором уже захвачены какие-то другие блокировки.</p>
    <p>Иногда, например, блокировкам присваивают уровни, требуя при этом от нити захватывать блокировки в порядке от большего уровня к меньшему, но не в обратном. Так же нельзя захватывать несколько блокировок одного уровня.</p>
    <p>Например, в предыдущем примере про рыцарей, каждому рыцарю можно добавить его уникальный номер (id) и потребовать, чтобы блокировки происходили от большего id к меньшему.</p>
    <table class="table_example">
    <tbody><tr><th width="100%">Пример</th></tr>
    <tr>
    <td class="monospace_text wide-text"><b>class</b> KnightUtil<br>
{<br>
    &nbsp;<b>public static</b> void kill(Knight knight1, Knight knight2)<br>
    &nbsp;{<br>
        &nbsp;&nbsp;Knight knightMax = knight1.id &gt; knight2.id ? knight1: knight2;<br>
        &nbsp;&nbsp;Knight knightMin = knight1.id &gt; knight2.id ? knight2: knight1;<br><br>

        &nbsp;&nbsp;<b>synchronized</b>(knightMax)<br>
        &nbsp;&nbsp;{<br>
            &nbsp;&nbsp;&nbsp;<b>synchronized</b>(knightMin)<br>
            &nbsp;&nbsp;&nbsp;{<br>
                &nbsp;&nbsp;&nbsp;&nbsp;knight2.live = 0;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;knight1.experiance +=100;<br>
            &nbsp;&nbsp;&nbsp;} <br>  
        &nbsp;&nbsp;}<br>
    &nbsp;}<br>
}
    </td>
    </tr>
    </tbody></table>
    <p class="amigo">- Красивое решение.</p>
    <p>- Это очень простое решение, но мне нравится. Надеюсь, оно тебе пригодится, когда ты будешь думать, как решать возможные проблемы с дедлоками.</p>
    <p class="amigo">- Спасибо, Элли.</p>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar diego"></div>
        <h2>6. Задачи по иправлению дедлоков</h2>
    </div>
    <p>- Привет, Амиго!</p>
    <table class="table_task">
        <tbody><tr>
            <th>Задачи</th>
        </tr>
        <tr>
            <td><button class="task_button" taskkey="level27,lesson06,task01" disabled=""></button><b>1. Убираем deadLock</b><br><br>
                Используя стратегию избегания <span class="taskcode">deadLock</span>-а сделайте так, чтобы он не возник.<br>
		Метод <span class="taskcode">main</span> не участвует в тестировании.<br>
		Действуйте аналогично примеру из лекций.<br>
		Изменения вносите только в <span class="taskcode">safeMethod</span>.
        </td></tr>
        <tr>
            <td><button class="task_button" taskkey="level27,lesson06,task02" disabled=""></button><b>2. Определяем порядок захвата монитора. Сложная.</b><br><br>
                Реализуйте логику метода <span class="taskcode">isNormalLockOrder</span>, который должен определять:<br>
		соответствует ли порядок <span class="taskcode">synchronized</span> блоков в методе <span class="taskcode">someMethodWithSynchronizedBlocks</span> - порядку передаваемых в него аргументов.<br>
		Метод <span class="taskcode">main</span> не участвует в тестировании.
            </td>
        </tr>
        <tr>
            <td><button class="idea-task-button"></button><b>3. Убираем deadLock, используя Открытые вызовы</b><br><br>
                Синхронизированные методы, которые вызывают внутри себя синхронизированные методы других классов, приводят к <span class="taskcode">dead-lock</span>-у.<br>
		1. Перенесите синхронизацию с метода в синхронизированный блок, куда поместите лишь необходимые части кода.<br>
		2. Уберите избыточную синхронизацию методов.<br>
		3. В стеке вызова методов не должно быть перекрестной синхронизации,<br>
		т.е. такого <span class="taskcode">synchronizedMethodAClass().synchronizedMethodBClass().synchronizedMethodAClass()</span><br><br>

		Этот способ избавления от дэдлока называется Открытые вызовы, о нем читайте в дополнительном материале к лекции.<br>
		Метод <span class="taskcode">main</span> не участвует в тестировании.

            </td>
        </tr>
	  
    </tbody></table>

    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar risha"></div>
        <h2>7. Стратегия "wait-notify-notifyAll"</h2>
    </div>
    <img src="res/image-ru-27-04.png" alt="" class="cartoon">
    <p>- Привет, Амиго!</p>
    <p>Хочу основательно разобрать с тобой тему wait-notify. Методы wait-notify обеспечивают удобный механизм взаимодействия нитей. Также их можно использовать для построения сложных высокоуровневых механизмов взаимодействия нитей.</p>
    <p>Начну с небольшого примера. Пусть у нас есть программа для сервера, которая должна выполнять различные задания, которые пользователи добавляют через сайт. Пользователи добавляют различные задания в разное время. Задачи ресурсоемкие, но сервер у нас с восьмиядерным процессором - справится. Как исполнять задачи на сервере?</p>
    <p>Во-первых, мы создадим группу нитей-исполнителей, столько же, сколько и количество ядер процессора. Каждая нить сможет работать на своем ядре: нити не будут друг другу мешать, а ядра процессора не будут простаивать.</p>
    <p>Во-вторых, создадим объект-очередь, в который будут помещаться полученные от пользователей задания.  Разным типам заданий будут соответствовать различные объекты, но все они будут реализовать интерфейс Runnable, чтобы их можно было выполнить.</p>
    <p class="amigo">- А можно пример такого объекта-задания?</p>
    <p>- Вот смотри:</p>
    <table class="table_example">
    <tbody><tr><th width="100%">Класс вычисляет факториал числа n при вызове метода run()</th></tr>
    <tr>
    <td class="monospace_text wide-text"><b>class</b> Factorial <b>implements Runnable</b><br>
{<br>
  &nbsp;<b>public</b> int n = 0;<br>
  &nbsp;<b>public</b> long result = 1;<br><br>
  
  &nbsp;<b>public</b> Factorial (int n)<br>
  &nbsp;{<br>
      &nbsp;&nbsp;this.n = n;<br>
  &nbsp;}<br><br>

  &nbsp;<b>public void run()</b><br>
  &nbsp;{<br>
       &nbsp;&nbsp;<b>for</b> (int i=2;i&lt;=n;i++)<br>
           &nbsp;&nbsp;&nbsp;result*=i;<br>
   &nbsp;}<br>
}
    </td>
    </tr>
    </tbody></table>
    <p class="amigo">- Пока ясно.</p>
    <p>- Отлично. Тогда разберем, как должен выглядеть объект-очередь. Что ты можешь сказать про него?</p>
    <p class="amigo">- Он должен быть thread-safe. В него кладутся объекты-задания (таски) нитью, которая принимает их от пользователей, а забираются задания нитями-исполнителями.</p>
    <p>- Ага. А если задания временно закончились?</p>
    <p class="amigo">- Тогда нити-исполнители должны ждать, пока они появятся.</p>
    <p>- Верно. Тогда представь, что все это можно встроить в одну очередь. Вот смотри:</p>
    <table class="table_example">
    <tbody><tr><th width="100%">Очередь заданий, если задания нет, то нить засыпает и ждет его появления:</th></tr>
    <tr>
    <td class="monospace_text wide-text"><b>public class</b> JobQueue<br>
{<br>
    &nbsp;ArrayList&lt;Runnable&gt; jobs = new ArrayList&lt;Runnable&gt;();<br><br>

    &nbsp;<b>public synchronized</b> void <b>put</b>(Runnable job)<br>
    &nbsp;{<br>
        &nbsp;&nbsp;jobs.add(job);<br>
        &nbsp;&nbsp;this.<span class="red_text"><b>notifyAll</b></span>();<br>
    &nbsp;}<br><br>

    &nbsp;<b>public synchronized</b> Runnable <b>getJob</b>()<br>
    &nbsp;{<br>
        &nbsp;&nbsp;<b>while</b> (jobs.size()==0)<br>
            &nbsp;&nbsp;&nbsp;this.<span class="red_text"><b>wait</b></span>();<br><br>

        &nbsp;&nbsp;return jobs.remove(0);<br>
    &nbsp;}<br>
}
    </td>
    </tr>
    </tbody></table>
    <p>У нас есть метод <b>getJob</b>, который  смотрит, если список работы (jobs) пуст, то нить засыпает (wait), пока в списке что-то не появится.</p>
    <p>А есть еще метод <b>put</b>, который позволяет добавить в список jobs новое задание (job). Как только новое задание добавлено, вызывается метод <b>notifyAll</b>. Вызов этого метода пробудит все нити-исполнители, которые заснули внутри метода getJob.</p>
    <p class="amigo">- А можешь напомнить еще раз, как работают методы wait и notify?</p>
    <p>- Метод wait вызывается только внутри блока synchronized, у объекта-мютекса. В нашем случае – это this. При этом происходит две вещи:</p>
    <p><b>1)</b> Нить засыпает.</p>
    <p><b>2)</b> Нить временно освобождает мютекс (пока не проснется).</p>
    <p>После этого другие нити могу входить в блок <b>synchronized</b> и занимать этот же мютекс.</p>
    <p>Метод <b>notifyAll</b> тоже можно вызвать только внутри блока <b>synchronized</b> у объекта-мютекса.  В нашем случае – это this. При этом происходит две вещи:</p>
    <p><b>1)</b> Просыпаются все нити, которые заснули на этом же объекте-мютексе.</p>
    <p><b>2) Как только текущая нить выйдет из блока synchronized, одна из проснувшихся нитей захватит мютекс и продолжит свою работу. Когда она освободит мютекс, другая проснувшаяся нить захватит мютекс и т.д.</b></p>
    <p>Очень похоже на автобус. Вы заходите внутрь, хотите передать за проезд, а водителя нет. И вы «засыпаете». Со временем вас набивается целый автобус, но за проезд пока никто не передает – некому. Затем заходит водитель, вы слышите « – Передаем за проезд».  И тут начинается...</p>
    <p class="amigo">- Интересное сравнение. А что такое автобус?</p>
    <p>- А это Хулио рассказывал. Были такие странные штуки в 21 веке. </p>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar risha"></div>
        <h2>8. Нюансы работы</h2>
    </div>
    <p>- Привет, Амиго!</p>
    <p>И еще пара деталей. Так сказать практических советов.</p>
    <p>Пусть у тебя есть метод, который что-то ждет и засыпает, пока условие не выполнено.</p>
    <table class="table_example">
    <tbody><tr><th width="100%">Если коллекция пустая, то ждем</th></tr>
    <tr>
    <td class="monospace_text wide-text"><b>public synchronized</b> Runnable getJob()<br>
    {<br>
        &nbsp;<b>if</b> (jobs.size()==0)<br>
            &nbsp;&nbsp;<span class="red_text"><b>this.wait();</b></span><br><br>

        &nbsp;return jobs.remove(0);<br>
    }
    </td>
    </tr>
    </tbody></table>
    <p>В документации по Java очень старательно советуют вызвать метод wait в цикле:</p>
    <table class="table_example">
    <tbody><tr><th width="100%">Если коллекция пустая, то ждем</th></tr>
    <tr>
    <td class="monospace_text wide-text"><b>public synchronized</b> Runnable getJob()<br>
    {<br>
        &nbsp;<b>while</b> (jobs.size()==0)<br>
            &nbsp;&nbsp;<span class="red_text"><b>this.wait();</b></span><br><br>

        &nbsp;return jobs.remove(0);<br>
    }
    </td>
    </tr>
    </tbody></table>
    <p>Зачем это надо. Дело в том, что если нить разбудили – это еще не значит, что условие выполнится. Может, там таких спящих нитей было два десятка. Разбудили всех, а задание забрать сможет только одна.</p>
    <p>Грубо говоря, могут быть «ложные побудки». Хороший разработчик должен учитывать это дело.</p>
    <p class="amigo">- Ясно.  А не проще ли тогда использовать просто notify?</p>
    <p>- А если в списке больше чем одно задание? Notify обычно советуют использовать ради оптимизации. Во всех остальных случаях рекомендуют использовать метод notifyAll.</p>
    <p class="amigo">- Ок.</p>
    <p>- Но и это еще не все. Во-первых, может возникнуть ситуация, когда кто-то унаследовался от твоего класса, добавил туда свои методы и тоже использует wait/notifyAll. Т.е. может быть ситуация, когда  на одном объекте висят независимые пары wait/notifyAll, которые друг о друге не знают. Поэтому  что надо делать?</p>
    <p class="amigo">- Всегда вызывать wait в цикле и проверять, что условие выхода из цикла действительно выполнилось!</p>
    <p>- Правильно. А чтобы тебе стало совсем понятно, что от этого никуда не деться, то многие разработчики указывают на то, что иногда нити просыпаются сами. Нити, которые гарантированно никто не может будить случайно. Похоже это побочный процесс оптимизации/ускорения кода в работающей Java-машине.</p>
    <p class="amigo">- Ничего себе. Понял, без цикла перед wait никуда.</p>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar diego"></div>
        <h2>9. Задачи на "wait-notify-notifyAll"  </h2>
    </div>
    <img src="res/image-ru-27-03.png" alt="" class="cartoon">
    <p>- Привет, Амиго!</p>
    <table class="table_task">
        <tbody><tr>
            <th>Задачи</th>
        </tr>
        <tr>
            <td><button class="task_button" taskkey="level27,lesson09,task01" disabled=""></button><b>1. CountDownLatch</b><br><br>
                Дана стандартная реализация методологии <span class="taskcode">wait-notify</span>.<br>
		Почитайте про <span class="taskcode">CountDownLatch</span> и перепишите тело метода <span class="taskcode">someMethod</span> используя поле <span class="taskcode">latch</span>.<br>
		Весь лишний код удалите из класса.
        </td></tr>
        <tr>
            <td><button class="idea-task-button"></button><b>2. Producer–consumer</b><br><br>
                В классе <span class="taskcode">TransferObject</span> расставьте вызов методов <span class="taskcode">wait</span>/<span class="taskcode">notify</span>/<span class="taskcode">notifyAll</span>,<br>
		чтобы обеспечить последовательное создание и получение объекта.<br>
		Метод <span class="taskcode">main</span> не участвует в тестировании
            </td>
        </tr>
        <tr>
            <td><button class="idea-task-button"></button><b>3. Расставьте wait-notify</b><br><br>
                Расставьте <span class="taskcode">wait-notify</span>.<br><br>
		<span class="example-legacy">Пример вывода:</span><br>
		<span class="example-data">Thread-0 MailServer has got: [Person [Thread-1] has written an email 'AAA'] in 1001 ms after start</span>
            </td>
        </tr>
	  
    </tbody></table>

    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar risha"></div>
        <h2>10. Другие детали синхронизации и многонитиевости</h2>
    </div>
    <p>- Привет, Амиго!</p>
    <p>Есть такая здоровенная тема, называется Java Memory Model. В принципе знать ее тебе пока не обязательно, но услышать про это – будет полезно.</p>
    <p>С целью устранить все возможные проблемы, в Java изменили механизм работы памяти. Теперь память не просто делится на локальный кэш нити и глобальную, а механизм стал еще лучше.</p>
    <p class="amigo">- И сложнее!</p>
    <p>- Да, лучше и сложнее. Это как самолет. Летать на самолете лучше, чем идти пешком, но сложнее. Попробую объяснить тебе новую ситуацию очень упрощенно.</p>
    <p>Вот, что было придумано. <span class="red_text"><b>В код был добавлен механизм синхронизации локальной памяти нитей, названный «happens before» (дословно «случилось перед»). Был придуман ряд правил/условий, при наступлении которых память синхронизируется – обновляется до актуального состояния.</b></span></p>
    <p>Пример:</p>
    <table class="table_example">
    <tbody><tr><th width="10%">Порядок</th><th width="33%">Нить 1</th><th width="33%">Нить 2</th></tr>
    <tr>
    <td class="wide-text"><b>1<br>
    2<br>
    …<br>
    101<br>
    102<br>
    103<br>
    104<br>
    105<br>
    …<br>
    201<br>
    202<br>
    203<br>
    204<br>
    205</b>
    </td>
    <td class="monospace_text"><b>public</b> int y = 1;<br>
<b>public</b> int x = 1;<br><br>

x=2;<br>
synchronized(mutex)<br>
{<br>
   &nbsp;y = 2;<br>
}
    </td>
    <td class="wide-text">нить ждет освобождения мютекса - mutex<br><br><br>


<span class="monospace_text">synchronized(mutex)<br>
{<br>
   &nbsp;<b>if</b> (y == x)<br>
      &nbsp;&nbsp;System.out.println("YES");<br>
}</span>
    </td>
    </tr>
    </tbody></table>
    <p>Одно из таких условий – это захват освобожденного мютекса. Если мютекс был освобожден и снова захвачен, то перед захватом обязательно выполнится синхронизация памяти. Нить  2 увидит «самые новые» значения переменных x и y, даже если не объявлять их <b>volatile</b>.</p>
    <p class="amigo">- Как интересно. И много таких условий?</p>
    <p>- Достаточно, вот некоторые условия синхронизации памяти:</p>
    <ul>
     <li>В рамках одной нити любая команда <b>happens-before</b> (читается «случается перед») любой операцией, следующей за ней в исходном коде.</li>
     <li>Освобождение лока (unlock) <b>happens-before</b> захватом того же лока (lock).</li>
     <li>Выход из <b>synhronized</b> блока/метода <b>happens-before</b> вход в synhronized блок/метод на том же мониторе.</li>
     <li>Запись volatile поля <b>happens-before</b> чтение того же самого volatile поля.</li>
     <li>Завершение метода run экземпляра класса Thread <b>happens-before</b> выход из метода join() или возвращение false методом isAlive() экземпляром той же нити.</li>
     <li>Вызов метода start() экземпляра класса Thread <b>happens-before</b> начало метода run() экземпляра той же нити.</li>
     <li>Завершение конструктора <b>happens-before</b> начало метода finalize() этого класса</li>
     <li>Вызов метода interrupt() на нити <b>happens-before</b>, когда нить обнаружила, что данный метод был вызван, либо путем выбрасывания исключения InterruptedException, либо с помощью методов isInterrupted() или interrupted()</li>
    </ul>
    <p class="amigo">- Т.е. все немного сложнее, чем я думал?</p>
    <p>- Да, немного сложнее…</p>
    <p class="amigo">- Спасибо, Риша, буду думать.</p>
    <p>- Не заморачивайся сильно на эту тему. Придет время, сам все поймешь. Пока тебе лучше разбираться в основах, чем лезть в дебри внутреннего устройства Java-машины. Вот выйдет Java 8 и опять все поменяется.</p>
    <p class="amigo">- О_о. М-да. Некоторые вещи лучше не знать.</p>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar julio"></div>
        <h2>11. Учимся гуглить. (Как получить список файлов по маске)</h2>
    </div>
    <img src="res/image-ru-27-02.png" alt="" class="cartoon">
    <p>- Привет, Амиго!</p>
    <p>Продолжаем наши уроки – учимся гуглить.</p>
    <p>Вот тебе несколько заданий:</p>
    <table class="table_example">
    <tbody><tr><th width="10%">&nbsp;</th><th width="90%">Задания на поиск в интернете:</th></tr>
    <tr>
    <td class="wide-text"><b>1</b>
    </td>
                <td class="wide-text">Чем плох оператор goto?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>2</b>
    </td>
                <td class="wide-text">Что такое зарезервированные слова в Java?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>3</b>
    </td>
                <td class="wide-text">Что произойдет, если вызвать wait не в блоке synchronized?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>4</b>
    </td>
                <td class="wide-text">Что такое happens-before?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>5</b>
    </td>
                <td class="wide-text">Назначение и методы класса BlockedQueue?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>6</b>
    </td>
                <td class="wide-text">Как скомпилировать java-файл из консоли?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>7</b>
    </td>
                <td class="wide-text">Как запустить java-файл из консоли?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>8</b>
    </td>
                <td class="wide-text">Как запустить программу из нескольких скомпилированнх файлов из консоли?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>9</b>
    </td>
                <td class="wide-text">Как создать директорию с поддиректориями: (doc/release/com/javarush/test)?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>10</b>
    </td>
                <td class="wide-text">Как получить список файлов в директории по маске (шаблону) «*.doc»?
    </td>
                
    </tr>
    </tbody></table>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar professor"></div>
        <h2>12. Профессор дает доп. материал</h2>
    </div>
    <p>- Привет, Амиго!</p>
    <p>Вот тебе дополнительный материал по теме.</p>
    <p><a href="http://info.javarush.ru/JavaRush_lectures_discussion/2013/10/20/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-27.html" target="_blank">Ссылка на дополнительный материал</a></p>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar julio"></div>
        <h2>13. Хулио</h2>
    </div>
    <p>- Привет, Амиго!</p>
    <p class="amigo">- Привет, Хулио. А скажи,  в честь  кого тебя назвали?</p>
    <p>- Во времена моей прапрапрапрабабушки был такой известный певец, Иглесиас.  Ну, вот теперь мне только осталось  научиться петь «Nostalgie».</p>
    <p class="amigo">- А как это, петь?</p>
    <p>- Сейчас покажу видео,  присаживайся.</p>

    <video poster="http://storage.javarush.ru/alpha/video/video-snapshot-ru-27.gif" controls="" preload="none" tabindex="0" class="movie-futurama" id="eyephoneMoviePlayer" taskkey="level27,lesson13,none01">
        <source src="http://storage.javarush.ru/alpha/video/video-ru-27.mp4" type="video/mp4">
    </video>
    <p></p><center><a href="https://www.youtube.com/watch?v=r6R04pXwC6g" target="_blank">Оригинал видео на YouTube</a></center><p></p>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar professor"></div>
        <h2>14. Вопросы к собеседованию по этой теме</h2>
    </div>
    <p>- Привет, Амиго!</p>
    <table class="table_example">
    <tbody><tr><th width="10%">&nbsp;</th><th width="90%">Вопросы к собеседованиям</th></tr>
    <tr>
    <td class="wide-text"><b>1</b>
    </td>
                <td class="wide-text">Что такое дедлок?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>2</b>
    </td>
                <td class="wide-text">Какие вы знаете стратегии, предотвращающие появление дедлоков?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>3</b>
    </td>
                <td class="wide-text">Могут ли возникнуть дедлоки при использовании методов wait-notify?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>4</b>
    </td>
                <td class="wide-text">Что чаще используется: notify или notifyAll?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>5</b>
    </td>
                <td class="wide-text">Метод wait рекомендуется использовать с конструкциями if или while?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>6</b>
    </td>
                <td class="wide-text">Что происходит после вызова метода notifyAll?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>7</b>
    </td>
                <td class="wide-text">Какие выгоды получает объект, если он immutable?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>8</b>
    </td>
                <td class="wide-text">Что такое «thread-safe»?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>9</b>
    </td>
                <td class="wide-text">Что такое "happens-before"?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>10</b>
    </td>
                <td class="wide-text">Что такое JMM?
    </td>
                
    </tr>
    <tr>
    <td class="wide-text"><b>11</b>
    </td>
                <td class="wide-text">Какое исключение вылетит, если вызвать wait не в блоке synchronized?
    </td>
                
    </tr>
    
    </tbody></table>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section><section class="lesson" style="">
    <div class="section_header">
        <div class="avatar zapp"></div>
        <h2>15. Большая задача</h2>
    </div>
    <p>- Привет, Амиго!</p>
    <p>Сегодня ты начинаешь работу над супер современной и полезной программой! Это – электронное меню. Вот:</p>
    <img src="res/image-ru-27-01.jpg" alt="" class="cartoon">
    <p class="amigo">- Круто! А для чего это?</p>
    <p>- Что-то ты много вопросов задаешь! Вот сделаешь, потом поговорим. Иди к секретному агенту, он даст тебе все необходимые инструкции.</p>
    <p class="amigo">- Товарищ  Капитан,  я не умею так красиво рисовать!</p>
    <p>- Запомни, тебе нужно реализовать необходимую бизнес логику, а картинки будет рисовать дизайнер. Иди к секретному агенту, по ходу дела разберешься.</p>   
    <p class="amigo">- Есть разбираться!</p>
    <div class="section_footer">
        <button class="next_lesson" style="visibility: hidden;"></button>
        <div class="line"></div>
    </div>
</section>






























    

    

    
    

</div>















</body></html>